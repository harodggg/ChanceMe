在加密货币中，私钥允许用户访问其钱包。持有私钥的人完全控制该钱包中数字货币。出于这个原因，你应该保守秘密。如果你真的想自己生成密钥，那么以安全的方式生成密钥是有意义的。在这里，我将介绍私钥，并向你展示如何使用各种加密函数生成自己的密钥。我将在Python中提供算法和代码的描述。
我需要生成私钥吗？
大多数时候你没有。例如，如果你使用Coinbase或Blockchain.info等网络钱包，他们会为你创建和管理私钥。交易所也是如此。

移动和桌面钱包通常也会为你生成私钥，但他们可以选择使用你自己的私钥创建钱包。

那么为什么要生成呢？以下是我的原因：

你想确保没有人知道密钥。
你只想了解有关加密和随机数生成（RNG）的更多信息。
什么是私钥？
什么是私钥？
形式上，比特币（以及许多其他加密货币）的私钥是一系列32字节。现在，有很多方法可以记录这些字节。它可以是256个1和0（32*8=256）或100个骰子所组成的字符串。它可以是二进制字符串，Base64字符串，WIF密钥，助记符短语，或最后是十六进制字符串。出于我们的目的，我们将使用64个字符长的十六进制字符串。

形式上，比特币（以及许多其他加密货币）的私钥是一系列32字节。现在，有很多方法可以记录这些字节。它可以是256个1和0（32*8=256）或100个骰子所组成的字符串。它可以是二进制字符串，Base64字符串，WIF密钥，助记符短语，或最后是十六进制字符串。出于我们的目的，我们将使用64个字符长的十六进制字符串。

为什么正好是32字节？好问题！你可以看到，要从私有密钥创建公钥，比特币使用ECDSA或椭圆曲线数字签名算法。更具体地说，它使用一个称为secp256k1的特定曲线。

现在，该曲线具有256位的量级，以256位作为输入，并输出256位整数。256位正好是32个字节。因此，换句话说，我们需要32字节的数据来提供给这种曲线算法。

私钥还有一个额外的要求。因为我们使用ECDSA，所以关键应该是正数，并且应该小于曲线的顺序。secp256k1的顺序是FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141，它非常大：几乎任何32字节的数字都会比它小。

简单粗暴的方法
那么，我们如何生成一个32字节的整数？ 首先想到的是只使用你选择的语言的RNG库。Python甚至提供了一种生成足够位的友好方式：

import random
bits = random.getrandbits(256)
# 30848827712021293731208415302456569301499384654877289245795786476741155372082
bits_hex = hex(bits)
# 0x4433d156e8c53bf5b50af07aa95a29436f29a94e0ccc5d58df8e57bdc8583c32
private_key = bits_hex[2:]
# 4433d156e8c53bf5b50af07aa95a29436f29a94e0ccc5d58df8e57bdc8583c32
看起来很好，但实际上，它不是。你看，普通的RNG库不适用于加密，因为它们不是很安全。它们根据种子生成数字，默认情况下，种子是当前时间。这样，如果你大致知道我上面生成的那些位，你需要做的就是暴力破解一些变种。

生成私钥时，你希望非常安全。请记住，如果有人学习私钥，他们可以轻松地从相应的钱包中窃取所有硬币，而你没有机会将其取回。

所以让我们尝试更安全地做到这一点。


密码学上强大的RNG
除了标准的RNG方法，编程语言通常还提供专门用于加密操作的RNG。这种方法通常更加安全，因为它直接从操作系统中提取熵。这种RNG的结果很难再现。你不能通过知道生成时间或种子来做到这一点，因为没有种子。好吧，至少用户不输入种子；相反，它是由程序创建的。

在Python中，密码强的RNG在secrets模块中实现。让我们修改上面的代码，使私钥生成安全！

import secrets
bits = secrets.randbits(256)
# 46518555179467323509970270980993648640987722172281263586388328188640792550961
bits_hex = hex(bits)
# 0x66d891b5ed7f51e5044be6a7ebe4e2eae32b960f5aa0883f7cc0ce4fd6921e31
private_key = bits_hex[2:]
# 66d891b5ed7f51e5044be6a7ebe4e2eae32b960f5aa0883f7cc0ce4fd6921e31
这是惊人的。我敢打赌，即使访问我的电脑，你也无法重现这一点。但我们可以更深入了吗？

专业的网站
有些网站会为你生成随机数。我们在这里只考虑两个。一个是random.org ，一个众所周知的通用随机数发生器。另一个是bitaddress.org ，专门用于比特币私钥生成。

random.org可以帮助我们生成密钥吗？ 当然，因为他们有生成随机字节的服务 。但是这里出现了两个问题。Random.org声称是一个真正的随机发生器，但你能相信吗？ 你能确定它确实是随机的吗？ 你能确定所有者不记录所有代的结果，特别是那些看起来像私钥的结果吗？ 答案取决于你。哦，你不能在本地运行它，这是一个额外的问题。此方法不是100％安全。

现在，bitaddress.org是一个完全不同的故事。它是开源的，所以你可以看到它的内部代码。它是客户端，因此即使没有Internet连接，你也可以下载并在本地运行它。

那么它是怎样工作的？ 它使用你——是的，你自己——作为熵的来源。它会要求你移动鼠标或按随机键。你做得足够长，使得重现结果变得不可行。

通过随机移动鼠标生成熵的过程。大块符号显示了pool。

你是否有兴趣了解bitaddress.org的工作原理？出于学习目的，我们将查看其代码并尝试在Python中重现它。

快速说明：bitaddress.org为你提供压缩WIF格式的私钥，该格式接近我们之前讨论过的WIF格式。出于我们的目的，我们将使算法返回一个十六进制字符串，以便我们以后可以使用它来生成公钥。

Bitaddress：具体细节
Bitaddress以两种形式创建熵：通过鼠标移动和按键压力。我们将讨论两者，但我们将重点关注按键，因为很难在Python lib中实现鼠标跟踪。我们希望最终用户在我们有足够的熵之前键入按钮，然后我们将生成一个密钥。

Bitaddress做了三件事。它初始化字节数组，试图从你的计算机获得尽可能多的熵，它用用户输入填充数组，然后生成一个私钥。

Bitaddress使用256字节数组来存储熵。这个数组是循环重写的，所以当第一次填充数组时，指针变为零，并且填充过程再次开始。

程序从window.crypto启动一个256字节的数组。然后，它写入时间戳以获得额外的4个字节的熵。最后，它获取的数据包括屏幕大小，时区，浏览器插件信息，区域设置等。这给了它另外6个字节。

初始化之后，程序不断等待用户输入以重写初始字节。当用户移动光标时，程序会写入光标的位置。当用户按下按钮时，程序会写入按下的按钮的字符代码。

最后，bitaddress使用累积的熵来生成私钥。它需要生成32个字节。对于此任务，bitaddress使用名为ARC4的RNG算法。程序用当前时间初始化ARC4并收集熵，然后逐个获取32次字节。

这完全是对程序运作方式的过度简化，但我希望你能得到这个想法。你可以在Github上详细查看算法。


for i in { 1...1000 }

